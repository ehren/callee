#pragma once

#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>

//#include <concepts>
//#include <ranges>
//#include <numeric>


#include "ceto.h"


#include "visitor.donotedit.autogenerated.h"
;
#include "ast.donotedit.autogenerated.h"
;
#include "utility.donotedit.autogenerated.h"
;
struct EvalableAstReprVisitor : public BaseVisitor<EvalableAstReprVisitor> {

    bool preserve_source_loc;

    bool ceto_evalable;

    decltype(std::string {""}) repr = std::string {""};

        template <typename T1>
auto generate_loc(const T1& node) -> void {
if (!preserve_source_loc) {
                return;
            }
            const auto loc = std::get<1>(ceto::mado(node)->source);
            (this -> repr) += (("(\"\", " + std::to_string(loc)) + ")");
        }

        inline auto visit(const Node&  node) -> void override {
            (this -> repr) += (std::string(typeid_name(node)) + "(");
if (ceto::mado(node)->func) {
                ceto::mado(ceto::mado(node)->func)->accept((*this));
                (this -> repr) += ", ";
            }
            (this -> repr) += "[";
if (ceto::mado(ceto::mado(node)->args)->size() > 0) {
                for(const auto& arg : ceto::mado(node)->args) {
                    ceto::mado(arg)->accept((*this));
                    (this -> repr) += ", ";
                }
            }
            (this -> repr) += ((std::string {"]"} + [&]() {if (ceto_evalable) {
                return ": Node";
            } else {
                return "";
            }}()
) + ", ");
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const UnOp&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(\"") + ceto::mado(node)->op) + "\", [");
            ceto::mado(ceto::maybe_bounds_check_access(ceto::mado(node)->args,0))->accept((*this));
            (this -> repr) += ((std::string {"]"} + [&]() {if (ceto_evalable) {
                return ": Node";
            } else {
                return "";
            }}()
) + ", ");
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const LeftAssociativeUnOp&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(\"") + ceto::mado(node)->op) + "\", [");
            ceto::mado(ceto::maybe_bounds_check_access(ceto::mado(node)->args,0))->accept((*this));
            (this -> repr) += ((std::string {"]"} + [&]() {if (ceto_evalable) {
                return ": Node";
            } else {
                return "";
            }}()
) + ", ");
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const BinOp&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(\"") + ceto::mado(node)->op) + "\", [");
            for(const auto& arg : ceto::mado(node)->args) {
                ceto::mado(arg)->accept((*this));
                (this -> repr) += ", ";
            }
            (this -> repr) += ((std::string {"]"} + [&]() {if (ceto_evalable) {
                return ": Node";
            } else {
                return "";
            }}()
) + ", ");
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const Identifier&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(\"") + ceto::mado(node)->repr()) + "\"");
            (this -> repr) += ", ";
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const StringLiteral&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(") + ceto::mado(node)->escaped()) + ", ");
if (ceto::mado(node)->prefix) {
                ceto::mado(ceto::mado(node)->prefix)->accept((*this));
            } else {
                (this -> repr) += "None";
            }
            (this -> repr) += ", ";
if (ceto::mado(node)->suffix) {
                ceto::mado(ceto::mado(node)->suffix)->accept((*this));
            } else {
                (this -> repr) += "None";
            }
            (this -> repr) += ", ";
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const IntegerLiteral&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(\"") + ceto::mado(node)->integer_string) + "\", ");
if (ceto::mado(node)->suffix) {
                ceto::mado(ceto::mado(node)->suffix)->accept((*this));
            } else {
                (this -> repr) += "None";
            }
            (this -> repr) += ", ";
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

        inline auto visit(const FloatLiteral&  node) -> void override {
            (this -> repr) += (((std::string(typeid_name(node)) + "(\"") + ceto::mado(node)->float_string) + "\", ");
if (ceto::mado(node)->suffix) {
                ceto::mado(ceto::mado(node)->suffix)->accept((*this));
            } else {
                (this -> repr) += "None";
            }
            (this -> repr) += ", ";
            this -> generate_loc(node);
            (this -> repr) += ")";
        }

    explicit EvalableAstReprVisitor(bool preserve_source_loc, bool ceto_evalable) : preserve_source_loc(preserve_source_loc), ceto_evalable(ceto_evalable) {}

    EvalableAstReprVisitor() = delete;

};

