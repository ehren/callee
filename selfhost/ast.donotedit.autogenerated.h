#pragma once

#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>

//#include <concepts>
//#include <ranges>
//#include <numeric>


#include "ceto.h"


#include <map>
;
#include <typeinfo>
;
#include "visitor.donotedit.autogenerated.h"
;
#include "utility.donotedit.autogenerated.h"
;
#include "range_utility.donotedit.autogenerated.h"
;
struct Node;

struct Scope;

struct Node : public ceto::shared_object, public std::enable_shared_from_this<Node> {

    std::shared_ptr<const Node> func;

    std::vector<std::shared_ptr<const Node>> args;

    std::tuple<std::string, int> source;

    std::shared_ptr<const Node> declared_type = nullptr; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(nullptr), std::remove_cvref_t<decltype(declared_type)>>);

    std::shared_ptr<const Scope> scope = nullptr; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(nullptr), std::remove_cvref_t<decltype(scope)>>);

    std::weak_ptr<const Node> _parent = {};

    std::string header_path_cth = {};

    std::string header_path_h = {};

         virtual inline auto classname() const -> std::string {
            return typeid_name((*this));
        }

         virtual inline auto repr() const -> std::string {
            const auto classname = this -> classname();
            const auto csv = join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ");
            return (((((classname + "(") + (*ceto::mad(this -> func)).repr()) + ")([") + csv) + "])");
        }

         virtual inline auto name() const -> std::optional<std::string> {
            return std::nullopt;
        }

         virtual inline auto accept( Visitor &  visitor) const -> void {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone_func_args() -> void {
            for(const auto& i : range((*ceto::mad(this -> args)).size())) {
                ceto::maybe_bounds_check_access(this -> args,i) = (*ceto::mad(ceto::maybe_bounds_check_access(this -> args,i))).clone();
            }
            if (this -> func) {
                (this -> func) = (*ceto::mad(this -> func)).clone();
            }
        }

         virtual inline auto clone() const -> std::shared_ptr<Node> {
            auto c { std::make_shared<Node>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

        inline auto parent() const -> auto {
            return (*ceto::mad(this -> _parent)).lock();
        }

        inline auto set_parent(const std::shared_ptr<const Node>&  p) -> void {
            (this -> _parent) = p;
        }

         virtual ~Node() {
            ; // pass
        }

    explicit Node(const std::shared_ptr<const Node>&  func, const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : func(func), args(args), source(source) {
    }

    Node() = delete;

};

struct UnOp : public Node {

    std::string op;

        inline auto repr() const -> std::string override {
            return ((((std::string {"("} + (this -> op)) + " ") + (*ceto::mad(ceto::maybe_bounds_check_access(this -> args,0))).repr()) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<UnOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit UnOp(const std::string&  op, const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, args, source), op(op) {
    }

    UnOp() = delete;

};

struct LeftAssociativeUnOp : public Node {

    std::string op;

        inline auto repr() const -> std::string override {
            return (((("(" + (*ceto::mad(ceto::maybe_bounds_check_access(this -> args,0))).repr()) + " ") + (this -> op)) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<LeftAssociativeUnOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit LeftAssociativeUnOp(const std::string&  op, const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, args, source), op(op) {
    }

    LeftAssociativeUnOp() = delete;

};

struct BinOp : public Node {

    std::string op;

        inline auto lhs() const -> auto {
            return ceto::maybe_bounds_check_access(this -> args,0);
        }

        inline auto rhs() const -> auto {
            return ceto::maybe_bounds_check_access(this -> args,1);
        }

        inline auto repr() const -> std::string override {
            return (((((("(" + (*ceto::mad(this -> lhs())).repr()) + " ") + (this -> op)) + " ") + (*ceto::mad(this -> rhs())).repr()) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<BinOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit BinOp(const std::string&  op, const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, args, source), op(op) {
    }

    BinOp() = delete;

};

struct TypeOp : public BinOp {

using BinOp::BinOp;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<TypeOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct SyntaxTypeOp : public TypeOp {

using TypeOp::TypeOp;

    std::shared_ptr<const Node> synthetic_lambda_return_lambda = nullptr; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(nullptr), std::remove_cvref_t<decltype(synthetic_lambda_return_lambda)>>);

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<SyntaxTypeOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct AttributeAccess : public BinOp {

using BinOp::BinOp;

        inline auto repr() const -> std::string override {
            return (((*ceto::mad(this -> lhs())).repr() + ".") + (*ceto::mad(this -> rhs())).repr());
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<AttributeAccess>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct ArrowOp : public BinOp {

using BinOp::BinOp;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<ArrowOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct ScopeResolution : public BinOp {

using BinOp::BinOp;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<ScopeResolution>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct Assign : public BinOp {

using BinOp::BinOp;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<Assign>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct NamedParameter : public Assign {

using Assign::Assign;

        inline auto repr() const -> std::string override {
            return ((std::string {"NamedParameter("} + join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ")) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<NamedParameter>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct BitwiseOrOp : public BinOp {

using BinOp::BinOp;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<BitwiseOrOp>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct Identifier : public Node {

    std::string _name;

        inline auto repr() const -> std::string override {
            return (this -> _name);
        }

        inline auto name() const -> std::optional<std::string> override {
            return (this -> _name);
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<Identifier>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit Identifier(const std::string&  name, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, std::vector<std::shared_ptr<const Node>>{}, source), _name(name) {
    }

    Identifier() = delete;

};

struct Call : public Node {

using Node::Node;

    decltype(false) is_one_liner_if = false;

        inline auto repr() const -> std::string override {
            const auto csv = join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ");
            return ((((*ceto::mad(this -> func)).repr() + "(") + csv) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<Call>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct ArrayAccess : public Node {

using Node::Node;

        inline auto repr() const -> std::string override {
            const auto csv = join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ");
            return ((((*ceto::mad(this -> func)).repr() + "[") + csv) + "]");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<ArrayAccess>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct BracedCall : public Node {

using Node::Node;

        inline auto repr() const -> std::string override {
            const auto csv = join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ");
            return ((((*ceto::mad(this -> func)).repr() + "{") + csv) + "}");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<BracedCall>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct Template : public Node {

using Node::Node;

        inline auto repr() const -> std::string override {
            const auto csv = join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ");
            return ((((*ceto::mad(this -> func)).repr() + "<") + csv) + ">");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<Template>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

    inline auto get_string_replace_function() -> auto {
        static std::function<std::string(std::string)> func = {};
        return func;
    }

    inline auto set_string_replace_function(const decltype(get_string_replace_function())  f) -> void {
        get_string_replace_function() = f;
    }

struct StringLiteral : public Node {

    std::string str;

    std::shared_ptr<const Identifier> prefix;

    std::shared_ptr<const Identifier> suffix;

        inline auto escaped() const -> auto {
            auto s { string_replace(this -> str, "\\", "\\\\") } ;
            s = string_replace(s, "\n", "\\n");
            s = string_replace(s, "\"", "\\\"");
            s = ((std::string {"\""} + s) + "\"");
            return s;
        }

        inline auto repr() const -> std::string override {
            return (([&]() {if (this -> prefix) {
                return (*ceto::mad_smartptr((*ceto::mad(this -> prefix)).name())).value();
            } else {
                return std::string {""};
            }}()
 + this -> escaped()) + [&]() {if (this -> suffix) {
                return (*ceto::mad_smartptr((*ceto::mad(this -> suffix)).name())).value();
            } else {
                return std::string {""};
            }}()
);
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<StringLiteral>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit StringLiteral(const std::string&  str, const std::shared_ptr<const Identifier>& prefix = nullptr, const std::shared_ptr<const Identifier>& suffix = nullptr, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, std::vector<std::shared_ptr<const Node>>{}, source), str(str), prefix(prefix), suffix(suffix) {
    }

    StringLiteral() = delete;

};

struct IntegerLiteral : public Node {

    std::string integer_string;

    std::shared_ptr<const Identifier> suffix;

        inline auto repr() const -> std::string override {
            return ((this -> integer_string) + [&]() {if (this -> suffix) {
                return (*ceto::mad_smartptr((*ceto::mad(this -> suffix)).name())).value();
            } else {
                return std::string {""};
            }}()
);
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<IntegerLiteral>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit IntegerLiteral(const std::string&  integer_string, const std::shared_ptr<const Identifier>& suffix = nullptr, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, {}, source), integer_string(integer_string), suffix(suffix) {
    }

    IntegerLiteral() = delete;

};

struct FloatLiteral : public Node {

    std::string float_string;

    std::shared_ptr<const Identifier> suffix;

        inline auto repr() const -> std::string override {
            return ((this -> float_string) + [&]() {if (this -> suffix) {
                return (*ceto::mad_smartptr((*ceto::mad(this -> suffix)).name())).value();
            } else {
                return std::string {""};
            }}()
);
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<FloatLiteral>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit FloatLiteral(const std::string&  float_string, const std::shared_ptr<const Identifier>&  suffix, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, {}, source), float_string(float_string), suffix(suffix) {
    }

    FloatLiteral() = delete;

};

struct ListLike_ : public Node {

        inline auto repr() const -> std::string override {
            const auto classname = this -> classname();
            return (((classname + "(") + join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ")) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<ListLike_>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit ListLike_(const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, args, source) {
    }

    ListLike_() = delete;

};

struct ListLiteral : public ListLike_ {

using ListLike_::ListLike_;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<ListLiteral>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct TupleLiteral : public ListLike_ {

using ListLike_::ListLike_;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<TupleLiteral>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct BracedLiteral : public ListLike_ {

using ListLike_::ListLike_;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<BracedLiteral>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct Block : public ListLike_ {

using ListLike_::ListLike_;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<Block>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct Module : public Block {

using Block::Block;

    decltype(false) has_main_function = false;

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<Module>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

};

struct RedundantParens : public Node {

        inline auto repr() const -> std::string override {
            const auto classname = this -> classname();
            return (((classname + "(") + join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ")) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<RedundantParens>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit RedundantParens(const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, args, source) {
    }

    RedundantParens() = delete;

};

struct InfixWrapper_ : public Node {

        inline auto repr() const -> std::string override {
            const auto classname = this -> classname();
            return (((classname + "(") + join(this -> args, [](const auto &a) {
                    if constexpr (!std::is_void_v<decltype((*ceto::mad(a)).repr())>) { return (*ceto::mad(a)).repr(); } else { static_cast<void>((*ceto::mad(a)).repr()); };
                    }, ", ")) + ")");
        }

        inline auto accept( Visitor &  visitor) const -> void override {
            (*ceto::mad(visitor)).visit((*this));
        }

        inline auto clone() const -> std::shared_ptr<Node> override {
            auto c { std::make_shared<InfixWrapper_>((*this)) } ;
            (*ceto::mad(c)).clone_func_args();
            return c;
        }

    explicit InfixWrapper_(const std::vector<std::shared_ptr<const Node>>&  args, const decltype(std::make_tuple(std::string {""}, 0)) source = std::make_tuple(std::string {""}, 0)) : Node (nullptr, args, source) {
    }

    InfixWrapper_() = delete;

};

