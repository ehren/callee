include (ast)
include (utility)

include <typeinfo>
include <ranges>

cpp'
#if _MSC_VER
#include <windows.h>
#define CETO_DLSYM GetProcAddress
#define CETO_DLOPEN LoadLibraryA
#define CETO_DLCLOSE FreeLibrary
#else
#include <dlfcn.h>
#define CETO_DLSYM dlsym
#define CETO_DLOPEN(L) dlopen(L, RTLD_NOW)
#define CETO_DLCLOSE dlclose
#endif
'

# def(name=functions_with_default_values, x: std.function = lambda(b), x: Identifier, b: ...:
#     return quote(unquote(x) : std.function(decltype(lambda(unpack(b)))) = lambda(unpack(b)))
# )

def (macro_matches, node: Node, pattern: Node, params: std.map<std.string, Node>:
    std.cout << "node: " << node.repr() << " pattern: " << pattern.repr()
    if (isinstance(pattern, Identifier):
        # matched_param = params[pattern.name().value()]  # error from using maybe_bounds_check with const map is highly confusing (and maybe requires clause is too constraining)
        search = params.find(pattern.name().value())
        if (search != params.end():

            param_name = search->first
            matched_param = search->second
            if (isinstance(matched_param, Identifier):
                # wildcard match
                return std.map<std.string, Node>{{param_name, node}}
            elif (typeop = asinstance(matched_param, TypeOp)):
                ast_name = typeop.rhs()

                # constrained wildcard / match by type
                if (isinstance(ast_name, Identifier):
                    # handle base class wild cards specially:
                    if (ast_name.name() == "BinOp" and isinstance(node, BinOp):
                        return std.map<string, Node>{{param_name, node}}
                    elif ast_name.name() == "UnOp" and isinstance(node, UnOp):
                        return std.map<std.string, Node>{{param_name, node}}
                    )

                    node_class_name = node.classname()
                    if (node_class_name == typeop.rhs().name().value():
                        return std.map<std.string, Node>{{param_name, node}}
                    )
                )
            )
        )
        # return {}
    )

    if (typeid(*node) != typeid(*pattern):
        return {}
    )

    if (node.args.size() != pattern.args.size():
        return {}
    )

    if ((node.func == None) != (pattern.func == None):
        return {}
    )

    if (node.args.size() == 0 and node.func == None and pattern.func == None:
        if (node.repr() == pattern.repr():
            # leaf match
            return std.map<std.string, Node>{}
        )
        return {}
    )

    submatches: mut = std.map<std.string, Node> {}

    for (i in std.ranges.iota_view(0u, node.args.size()):
        m = macro_matches(node.args[i], pattern.args[i], params)
        if (not m:
            return {}
        )
        submatches.insert(m.begin(), m.end())  # std::optional autoderef
    )

    if (node.func:
        m = macro_matches(node.func, pattern.func, params)
        if (not m:
            return {}
        )
        submatches.insert(m.begin(), m.end())
    )

    return submatches
) : std.optional<std.map<std.string, Node>>


def (macro_trampoline, macro_impl_name: std.string, macro_dll_path: std.string, match: std.map<std.string, Node>:
    # new_node = macro_trampoline(macro_impl_name, macro_dll_path, match)
    handle = CETO_DLOPEN(macro_dll_path.c_str())  # just leak it for now
    if (not handle:
        throw (std.runtime_error("Failed to open macro dll: "s + macro_dll_path))
    )
    fptr = CETO_DLSYM(handle, macro_impl_name.c_str())
    f = reinterpret_cast<decltype(+(lambda(m: std.map<string, Node>, None): Node))>(fptr)  # no explicit function ptr syntax yet/ever(?)
    return (*f)(match)
) : Node