include <map>
include <cassert>

include (ast)

class (ClassDefinition:
    name_node : Identifier
    class_def_node : Call
    is_unique: bool
    is_struct: bool
    is_forward_declaration: bool

    is_pure_virtual = false
    is_concrete = false
#    is_generic_param_index = std.map<int, bool>()
#
#    def (has_generic_params:
#        for ((k, v) in self.is_generic_param_index:
#            if (v:
#                return true
#            )
#        )
#
#        return false
#    )
)

class (InterfaceDefinition(ClassDefinition):
    def (init:
        super.init(None, None, false, false, false)
    )
)

class (VariableDefinition:
    defined_node: Identifier
    defining_node: Node
)

class (LocalVariableDefinition(VariableDefinition):
    pass
)

class (GlobalVariableDefinition(VariableDefinition):
    pass
)

class (FieldDefinition(VariableDefinition):
    pass
)

class (ParameterDefinition(VariableDefinition):
    pass
)

def (contains, container, element: const:typename:std.remove_reference_t<decltype(container)>::value_type:ref:
    return std.find(container.begin(), container.end(), element) != container.end()
)

def (creates_new_variable_scope, e: Node:
    call = dynamic_pointer_cast<const:Call.class>(e)
    if (call:
        name = call.func.name()
        return name and contains(["def", "lambda", "class", "struct"], name.value())
    )
    return false
)

class (Scope:
    interfaces = std.map<std.string, std.vector<Node>>()
    class_definitions: [ClassDefinition] = []
    variable_definitions: [VariableDefinition] = []
    indent = 0
    _parent: weak:Scope = {}
    in_function_body = false
    in_function_param_list = false  # TODO unused remove
    in_class_body = false
    in_decltype = false

    def (indent_str:
        return std.string(4*self.indent, char' ')
    )

    def (add_variable_definition: mut, defined_node: Identifier, defining_node: Node:
        parent: mut = defined_node.parent()

        while (parent:
            if (creates_new_variable_scope(parent):
                name = parent.func.name()
                if (name == "class" or name == "struct":
                    defn = FieldDefinition(defined_node, defining_node)
                    self.variable_definitions.push_back(defn)
                elif name == "def" or name == "lambda":
                    defn = ParameterDefinition(defined_node, defining_node)
                    self.variable_definitions.push_back(defn)
                else:
                    defn = LocalVariableDefinition(defined_node, defining_node)
                    self.variable_definitions.push_back(defn)
                )
                return
            )
            parent = parent.parent()
        )
        defn = GlobalVariableDefinition(defined_node, defining_node)
        self.variable_definitions.push_back(defn)
    )

    def (add_interface_method: mut, interface_name: std.string, interface_method_def_node: Node:
        if (self.interfaces.contains(interface_name):
            self.interfaces[interface_name].push_back(interface_method_def_node)
        else:
            self.interfaces[interface_name] = [interface_method_def_node]
        )
    )

    def (add_class_definition: mut, class_definition: ClassDefinition:
        self.class_definitions.push_back(class_definition)
    )

    def (lookup_class, class_node: Node:
        if (not dynamic_pointer_cast<const:Identifier.class>(class_node):
            return None
        )
        for (c in self.class_definitions:
            if (c.name_node.name() == class_node.name():
                return c
            )
        )
        if (self.interfaces.contains(class_node.name().value()):
            return InterfaceDefinition()
        )
        if ((s = self._parent.lock()):
            return s.lookup_class(class_node)
        )
        return None
    ) : ClassDefinition

    def (find_defs, var_node: Node, find_all=true:
        if (not dynamic_pointer_cast<const:Identifier.class>(var_node):
            return {}
        )

        results: mut = [] : VariableDefinition

        for (d in self.variable_definitions:
            if (d.defined_node.name() == var_node.name() and d.defined_node != var_node:
                defined_loc = std.get<1>(d.defined_node.source)
                var_loc = std.get<1>(var_node.source)

                if (defined_loc < var_loc:
                    if (not find_all:
                        return [d]
                    )
                    # TODO doesn't produce parseable c++ code???
#                    if ((assign = dynamic_pointer_cast<const:Assign.class>(d.defining_node)) and (ident = dynamic_pointer_cast<const:Identifier.class>(assign.rhs())):
#                        more: mut = self.find_defs(ident, find_all)
#                        results.insert(results.end(), more.begin(), more.end())
#                    )
                    assign = dynamic_pointer_cast<const:Assign.class>(d.defining_node)
                    if (assign:
                        ident = dynamic_pointer_cast<const:Identifier.class>(assign.rhs())
                        if (ident:
                            more = self.find_defs(ident, find_all)
                            results.insert(results.end(), more.begin(), more.end())
                        )
                    )
                )
            )
        )

        if ((s = self._parent.lock()):
            more = s.find_defs(var_node, find_all)
            results.insert(results.end(), more.begin(), more.end())
        )

        return results
    ) : [VariableDefinition]

    def (find_def, var_node: Node:
        find_all = false
        found = self.find_defs(var_node, find_all)
        return if (found.size() > 0:
            found[0]
        else:
            none_result : VariableDefinition = None
            none_result  # needed for lambda return type deduction; arguably expression-if usage here is silly.
        )
    )

    def (enter_scope:
        s: mut = Scope()
        s._parent = self
        s.in_function_body = self.in_function_body
        s.in_decltype = self.in_decltype
        s.indent = self.indent + 1
        return s
    ) : Scope

    def (parent:
        return self._parent.lock()
    )
)