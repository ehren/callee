include <map>
include <cassert>

include (ast)

class (ClassDefinition:
    name_node : Identifier
    class_def_node : Call
    is_unique: bool
    is_struct: bool
    is_forward_declaration: bool

    is_pure_virtual = false
    is_concrete = false
    is_generic_param_index = std.map<int, bool>()

    def (has_generic_params:
        for ((k, v) in self.is_generic_param_index:
            if (v:
                return true
            )
        )

        return false
    )
)

class (InterfaceDefinition(ClassDefinition):
    def (init:
        super.init(None, None, false, false, false)
    )
)

class (VariableDefinition:
    defined_node: Identifier
    defining_node: Node
)

class (LocalVariableDefinition(VariableDefinition):
    pass
)

class (GlobalVariableDefinition(VariableDefinition):
    pass
)

class (FieldDefinition(VariableDefinition):
    pass
)

class (ParameterDefinition(VariableDefinition):
    pass
)

def (contains, container, element: const:typename:std.remove_reference_t<decltype(container)>::value_type:ref:
    return std.find(container.begin(), container.end(), element) != container.end()
)

def (creates_new_variable_scope, e: Node:
    call = dynamic_pointer_cast<const:Node.class>(e)
    if (call:
        name = call.func.name()
        return name and contains(["def", "lambda", "class", "struct"], name.value())
    )
    return false
)

class (Scope:
    interfaces = std.map<std.string, Node>()
    class_definitions: [ClassDefinition] = []
    variable_definitions: [VariableDefinition] = []
    indent = 0
    _parent: weak:Scope = {}
    in_function_body = false
    in_function_param_list = false  # TODO unused remove
    in_class_body = false
    in_decltype = false

    def (indent_str:
        return std.string(4*self.indent, char' ')
    )

#    def (add_variable_definition: mut, defined_node: Identifier, defining_node: Node:
#        parent: mut = defined_node.parent()
##        defn: mut:decltype(VariableDefinition(defined_node, defining_node)) = None  # this is unfortunate
##        empty_const_defn: VariableDefinition = None
##        defn: mut = empty_const_defn  # also pretty bad
#        defn : mut:VariableDefinition = None  # having to work with mut instances (shared_ptr to non-const) also not great

#        although to be fair, needing defn to be mutable is a bit silly anyway (below impl better)
#
#        while (parent:
#            if (creates_new_variable_scope(parent):
#                name = parent.func.name()
#                if (name == "class" or name == "struct":
#                    defn = FieldDefinition(defined_node, defining_node) : mut
#                elif name == "def" or name == "lambda":
#                    defn = ParameterDefinition(defined_node, defining_node) : mut
#                else:
#                    defn = LocalVariableDefinition(defined_node, defining_node) : mut
#                )
#                break
#            )
#            parent = parent.parent()
#        )
#
#        assert(defn != None)
#        self.variable_definitions.push_back(defn)
#    )

    def (add_variable_definition: mut, defined_node: Identifier, defining_node: Node:
        parent: mut = defined_node.parent()

        while (parent:
            if (creates_new_variable_scope(parent):
                name = parent.func.name()
                if (name == "class" or name == "struct":
                    defn = FieldDefinition(defined_node, defining_node)
                    self.variable_definitions.push_back(defn)
                elif name == "def" or name == "lambda":
                    defn = ParameterDefinition(defined_node, defining_node)
                    self.variable_definitions.push_back(defn)
                else:
                    defn = LocalVariableDefinition(defined_node, defining_node)
                    self.variable_definitions.push_back(defn)
                )
                return
            )
            parent = parent.parent()
        )
    )

    def (lookup_class, class_node: Node:
        if (not dynamic_pointer_cast<const:Identifier.class>(class_node):
            return None
        )
        for (c in self.class_definitions:
            if (c.name_node.name() == class_node.name():
                return c
            )
        )
        if (self.interfaces.contains(class_node.name().value()):
            return InterfaceDefinition()
        )
        if ((s = self._parent.lock()):
            return s.lookup_class(class_node)
        )
        return None
    ) : ClassDefinition

    def (find_defs, var_node: Node, find_all=true:
        if (not dynamic_pointer_cast<const:Identifier.class>(var_node):
            return {}
        )

        results: mut = [] : VariableDefinition

        for (d in self.variable_definitions:
            if (d.defined_node.name() == var_node.name() and d.defined_node != var_node:
                defined_loc = std.get<1>(d.defined_node.source)
                var_loc = std.get<1>(var_node.source)

                if (defined_loc < var_loc:
                    if (not find_all:
                        return [d]
                    )
                    # TODO doesn't produce parseable c++ code???
#                    if ((assign = dynamic_pointer_cast<const:Assign.class>(d.defining_node)) and (ident = dynamic_pointer_cast<const:Identifier.class>(assign.rhs())):
#                        more: mut = self.find_defs(ident, find_all)
#                        results.insert(results.end(), more.begin(), more.end())
#                    )
                    assign = dynamic_pointer_cast<const:Assign.class>(d.defining_node)
                    if (assign:
                        ident = dynamic_pointer_cast<const:Identifier.class>(assign.rhs())
                        if (ident:
                            more: mut = self.find_defs(ident, find_all)
                            results.insert(results.end(), more.begin(), more.end())
                        )
                    )
                )
            )
        )

        if ((s = self._parent.lock()):
            more = s.find_defs(var_node, find_all)
            results.insert(results.end(), more.begin(), more.end())
        )

        return results
    ) : [VariableDefinition]

    def (find_def, var_node:
        find_all = false
        return self.find_defs(var_node, find_all)
    )

    def (enter_scope:
        s: mut = Scope()
        s._parent = self
        s.in_function_body = self.in_function_body
        s.in_decltype = self.in_decltype
        s.indent = self.indent + 1
        return s
    ) : Scope
)