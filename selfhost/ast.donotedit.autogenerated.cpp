
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"
#include "ceto_checked_array_access.donotedit.autogenerated.h"

#include <map>
;
#include <typeinfo>
;
#include <numeric>
;
#include <pybind11/pybind11.h>
;
#include <pybind11/stl.h>
;
#include <pybind11/stl_bind.h>
;
#include <pybind11/functional.h>
;
#include "ast.donotedit.autogenerated.h"
;
#include "scope.donotedit.autogenerated.h"
;
#include "evalable_repr.donotedit.autogenerated.h"
;
#include "parser.donotedit.autogenerated.h"
;
#include "macro_expansion.donotedit.autogenerated.h"
;
namespace py = pybind11;
    inline auto module_path() -> auto {
        const py::object module = py::module::import("ceto"); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(py::module::import("ceto")), std::remove_cvref_t<decltype(module)>>);
        const py::object os = py::module::import("os"); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(py::module::import("os")), std::remove_cvref_t<decltype(os)>>);
        const auto exeloc = (*ceto::mad(module)).attr("__file__");
        const auto dir = (*ceto::mad((*ceto::mad(os)).attr("path"))).attr(exeloc);
        return (*ceto::mad(dir)).cast<std::string>();
    }


PYBIND11_MODULE(_abstractsyntaxtree, m) {
;
[]( auto &&  m) {
        using namespace pybind11::literals;
        (*ceto::mad((*ceto::mad(py::class_<Source,std::shared_ptr<Source>>(m, "Source"))).def(py::init<>()))).def_readwrite("source", (&Source::source));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<SourceLoc>(m, "SourceLoc"))).def(py::init<std::shared_ptr<const Source>,int>(), py::arg("source") = nullptr, py::arg("loc") = 0))).def_readwrite("source", (&SourceLoc::source)))).def_readwrite("loc", (&SourceLoc::loc)))).def_readwrite("header_file_cth", (&SourceLoc::header_file_cth)))).def_readwrite("header_file_h", (&SourceLoc::header_file_h));
        auto node { (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<Node,std::shared_ptr<Node>>(m, "Node"))).def_readwrite("func", (&Node::func)))).def_readwrite("args", (&Node::args)))).def_readwrite("declared_type", (&Node::declared_type)))).def_readwrite("scope", (&Node::scope)))).def_readwrite("source", (&Node::source)))).def("clone", (&Node::clone)))).def("__repr__", (&Node::repr)))).def("ast_repr", [](const Node&  n, const bool  preserve_source_loc, const bool  ceto_evalable) {
                auto vis { EvalableAstReprVisitor{preserve_source_loc, ceto_evalable} } ;
                (*ceto::mad(n)).accept(vis);
                if constexpr (!std::is_void_v<decltype((*ceto::mad(vis)).repr)>) { return (*ceto::mad(vis)).repr; } else { static_cast<void>((*ceto::mad(vis)).repr); };
                }, py::arg("preserve_source_loc") = true, py::arg("ceto_evalable") = false))).def_property_readonly("name", (&Node::name)))).def_property("parent", (&Node::parent), (&Node::set_parent)) } ;
        (*ceto::mad((*ceto::mad(py::class_<UnOp,std::shared_ptr<UnOp>>(m, "UnOp", node))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("op", (&UnOp::op));
        (*ceto::mad((*ceto::mad(py::class_<LeftAssociativeUnOp,std::shared_ptr<LeftAssociativeUnOp>>(m, "LeftAssociativeUnOp", node))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("op", (&LeftAssociativeUnOp::op));
        auto binop { py::class_<BinOp,std::shared_ptr<BinOp>>(m, "BinOp", node) } ;
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(binop)).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("op", (&BinOp::op)))).def_property_readonly("lhs", (&BinOp::lhs)))).def_property_readonly("rhs", (&BinOp::rhs));
        auto typeop { py::class_<TypeOp,std::shared_ptr<TypeOp>>(m, "TypeOp", binop) } ;
        (*ceto::mad(typeop)).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad(py::class_<SyntaxTypeOp,std::shared_ptr<SyntaxTypeOp>>(m, "SyntaxTypeOp", typeop))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("synthetic_lambda_return_lambda", (&SyntaxTypeOp::synthetic_lambda_return_lambda));
        (*ceto::mad(py::class_<AttributeAccess,std::shared_ptr<AttributeAccess>>(m, "AttributeAccess", binop))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<ArrowOp,std::shared_ptr<ArrowOp>>(m, "ArrowOp", binop))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<ScopeResolution,std::shared_ptr<ScopeResolution>>(m, "ScopeResolution", binop))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<BitwiseOrOp,std::shared_ptr<BitwiseOrOp>>(m, "BitwiseOrOp", binop))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<EqualsCompareOp,std::shared_ptr<EqualsCompareOp>>(m, "EqualsCompareOp", binop))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        auto assign { py::class_<Assign,std::shared_ptr<Assign>>(m, "Assign", binop) } ;
        (*ceto::mad(assign)).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<NamedParameter,std::shared_ptr<NamedParameter>>(m, "NamedParameter", assign))).def(py::init<const std::string &,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad(py::class_<Call,std::shared_ptr<Call>>(m, "Call", node))).def(py::init<std::shared_ptr<const Node>,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("is_one_liner_if", (&Call::is_one_liner_if));
        (*ceto::mad(py::class_<ArrayAccess,std::shared_ptr<ArrayAccess>>(m, "ArrayAccess", node))).def(py::init<std::shared_ptr<const Node>,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<BracedCall,std::shared_ptr<BracedCall>>(m, "BracedCall", node))).def(py::init<std::shared_ptr<const Node>,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<Template,std::shared_ptr<Template>>(m, "Template", node))).def(py::init<std::shared_ptr<const Node>,const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<Identifier,std::shared_ptr<Identifier>>(m, "Identifier", node))).def(py::init<const std::string &,const SourceLoc &>(), py::arg("name"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<StringLiteral,std::shared_ptr<StringLiteral>>(m, "StringLiteral", node))).def(py::init<const std::string &,std::shared_ptr<const Identifier>,std::shared_ptr<const Identifier>,const SourceLoc &>(), py::arg("str"), py::arg("prefix"), py::arg("suffix"), py::arg("source") = SourceLoc()))).def_readonly("str", (&StringLiteral::str)))).def_readwrite("prefix", (&StringLiteral::prefix)))).def_readwrite("suffix", (&StringLiteral::suffix)))).def("escaped", (&StringLiteral::escaped));
        (*ceto::mad((*ceto::mad((*ceto::mad(py::class_<IntegerLiteral,std::shared_ptr<IntegerLiteral>>(m, "IntegerLiteral", node))).def(py::init<const std::string &,std::shared_ptr<const Identifier>,const SourceLoc &>(), py::arg("integer_string"), py::arg("suffix"), py::arg("source") = SourceLoc()))).def_readonly("integer_string", (&IntegerLiteral::integer_string)))).def_readonly("suffix", (&IntegerLiteral::suffix));
        (*ceto::mad((*ceto::mad((*ceto::mad(py::class_<FloatLiteral,std::shared_ptr<FloatLiteral>>(m, "FloatLiteral", node))).def(py::init<const std::string &,std::shared_ptr<const Identifier>,const SourceLoc &>(), py::arg("float_string"), py::arg("suffix"), py::arg("source") = SourceLoc()))).def_readonly("float_string", (&FloatLiteral::float_string)))).def_readonly("suffix", (&FloatLiteral::suffix));
        auto list_like { py::class_<ListLike_,std::shared_ptr<ListLike_>>(m, "ListLike_", node) } ;
        (*ceto::mad(py::class_<ListLiteral,std::shared_ptr<ListLiteral>>(m, "ListLiteral", list_like))).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<TupleLiteral,std::shared_ptr<TupleLiteral>>(m, "TupleLiteral", list_like))).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<BracedLiteral,std::shared_ptr<BracedLiteral>>(m, "BracedLiteral", list_like))).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        auto block { py::class_<Block,std::shared_ptr<Block>>(m, "Block", list_like) } ;
        (*ceto::mad(block)).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad(py::class_<Module,std::shared_ptr<Module>>(m, "Module", block))).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("has_main_function", (&Module::has_main_function));
        (*ceto::mad(py::class_<RedundantParens,std::shared_ptr<RedundantParens>>(m, "RedundantParens", node))).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<InfixWrapper_,std::shared_ptr<InfixWrapper_>>(m, "InfixWrapper_", node))).def(py::init<const std::vector<std::shared_ptr<const Node>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        auto class_def { (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<ClassDefinition,std::shared_ptr<ClassDefinition>>(m, "ClassDefinition"))).def(py::init<std::shared_ptr<const Identifier>,std::shared_ptr<const Call>,bool,bool,bool>(), py::arg("name_node"), py::arg("class_def_node"), py::arg("is_unique"), py::arg("is_struct"), py::arg("is_forward_declaration")))).def_readwrite("name_node", (&ClassDefinition::name_node)))).def_readwrite("class_def_node", (&ClassDefinition::class_def_node)))).def_readwrite("is_unique", (&ClassDefinition::is_unique)))).def_readwrite("is_struct", (&ClassDefinition::is_struct)))).def_readwrite("is_forward_declaration", (&ClassDefinition::is_forward_declaration)))).def_readwrite("is_concrete", (&ClassDefinition::is_concrete)))).def_readwrite("is_pure_virtual", (&ClassDefinition::is_pure_virtual)))).def("__repr__", (&ClassDefinition::repr)) } ;
        (*ceto::mad(py::class_<InterfaceDefinition,std::shared_ptr<InterfaceDefinition>>(m, "InterfaceDefinition", class_def))).def(py::init<>());
        auto variable_def { (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<VariableDefinition,std::shared_ptr<VariableDefinition>>(m, "VariableDefinition"))).def(py::init<std::shared_ptr<const Identifier>,std::shared_ptr<const Node>>(), py::arg("defined_node"), py::arg("defining_node")))).def_readwrite("defined_node", (&VariableDefinition::defined_node)))).def_readwrite("defining_node", (&VariableDefinition::defining_node)))).def("__repr__", (&VariableDefinition::repr)) } ;
        (*ceto::mad(py::class_<LocalVariableDefinition,std::shared_ptr<LocalVariableDefinition>>(m, "LocalVariableDefinition", variable_def))).def(py::init<std::shared_ptr<const Identifier>,std::shared_ptr<const Node>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad(py::class_<GlobalVariableDefinition,std::shared_ptr<GlobalVariableDefinition>>(m, "GlobalVariableDefinition", variable_def))).def(py::init<std::shared_ptr<const Identifier>,std::shared_ptr<const Node>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad(py::class_<FieldDefinition,std::shared_ptr<FieldDefinition>>(m, "FieldDefinition", variable_def))).def(py::init<std::shared_ptr<const Identifier>,std::shared_ptr<const Node>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad(py::class_<ParameterDefinition,std::shared_ptr<ParameterDefinition>>(m, "ParameterDefinition", variable_def))).def(py::init<std::shared_ptr<const Identifier>,std::shared_ptr<const Node>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<Scope,std::shared_ptr<Scope>>(m, "Scope"))).def(py::init<>()))).def_readwrite("indent", (&Scope::indent)))).def_readwrite("in_function_body", (&Scope::in_function_body)))).def_readwrite("in_function_param_list", (&Scope::in_function_param_list)))).def_readwrite("in_class_body", (&Scope::in_class_body)))).def_readwrite("in_decltype", (&Scope::in_decltype)))).def("indent_str", (&Scope::indent_str)))).def("add_variable_definition", (&Scope::add_variable_definition), "defined_node"_a, "defining_node"_a))).def("add_interface_method", (&Scope::add_interface_method)))).def("add_class_definition", (&Scope::add_class_definition)))).def("lookup_class", (&Scope::lookup_class)))).def("find_defs", (&Scope::find_defs), py::arg("var_node"), py::arg("find_all") = true))).def("find_def", (&Scope::find_def)))).def("enter_scope", (&Scope::enter_scope)))).def_property_readonly("parent", (&Scope::parent));
        (*ceto::mad(m)).def("creates_new_variable_scope", (&creates_new_variable_scope));
        (*ceto::mad(m)).def("parse_test", (&parse_test));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<MacroDefinition,std::shared_ptr<MacroDefinition>>(m, "MacroDefinition"))).def(py::init<std::shared_ptr<const Node>,std::shared_ptr<const Node>,std::map<std::string,std::shared_ptr<const Node>>>()))).def_readonly("defmacro_node", (&MacroDefinition::defmacro_node)))).def_readonly("pattern_node", (&MacroDefinition::pattern_node)))).def_readonly("parameters", (&MacroDefinition::parameters)))).def_readwrite("dll_path", (&MacroDefinition::dll_path)))).def_readwrite("impl_function_name", (&MacroDefinition::impl_function_name));
        (*ceto::mad(m)).def("macro_matches", (&macro_matches));
        (*ceto::mad(m)).def("expand_macros", (&expand_macros));
        return;
        }(m);
};
